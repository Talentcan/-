# 5.2 如何判断一个链表有环
思路：对于环形链表判断是否有环，都可以用快慢指针来做，快指针一次走两格，慢指针一次走一格。然后如果快指针能走到尽头，即fast.next==null，说明链表不成环；否则链表成环，或者快慢指针指向同一个元素也能证明链表成环。

## 扩展1.判断出链表成环，求环的长度

当两个指针第一次相遇说明成环，然后继续运行，当第二次相遇时，统计的前进步数就是环的长度。相当于相遇时在同一起点，快指针比慢指针快一倍，下一次相遇快指针就比慢指针多走了一圈。

## 扩展2.判断出链表成环，求入环的节点

当两个指针第一次相遇说明成环，然后将快指针重新放置到链表开头，并且让它每次只移动一格，当两个指针再次相遇时指向的元素就是入环的节点。




# 5.3实现最小栈，可以直接返回栈中的最小元素，getmin();
思路：不能单纯的使用一个变量来存储最小值的下标，这样如果那个元素出栈后，就会找不到最小元素。应该用两个栈来存储元素。一个栈用来存储最小元素，min。当第一个元素入栈是，同时也进入min栈，然后接着进入的元素要先与min中栈顶元素比较，如果小于原来的最小值，则这个元素要进入两个栈，否则就只用进主栈。当数据出栈时，如果出栈的数据是最小的元素，那么min栈也要出栈，让本来第二小的元素成为最小。当执行返回最小元素的方法时，返回min栈的栈顶元素




# 5.4求最大公约数
思路：有辗转相除法，更相减损术，然后将他们的优点结合出来的第三种方法

辗转相除法（欧几里得算法）：a>b，gcd(a,b) == gcd(b,a%b)

更相减损术：a>b, gcd(a,b) == gcd(b,a-b)

结合：使用位运算

当两个数为偶数： gcd(a,b) == 2*gcd(a/2,b/2) == gcd(a>>1,b>>1)<<1

当一个数为奇数：b奇数， gcd(a,b) == gcd(a/2,b) == gcd(a>>1,b)

当两个数为奇数：先进行一次更相减损术，将一个数变为偶数，然后进行上一步

在判断奇偶时，还可以用按位与&来进行



# 5.5判断一个数是否为2的整数次幂
思路：当一个数n是2的整数次幂时，n的二进制，除了最高位是1，其余位都是0，n-1的二进制每个位上都是1。所以如果一个数n是2的整数次幂，则n&(n-1)==0



# 5.7用栈来实现队列
思路：使用两个栈来实现队列，栈A和栈B。当元素入栈时，进栈A。元素出栈时，先将元素从栈A中出栈然后压入栈B中，这样元素就会进行翻转符合数据出队列的顺序，然后出栈就从栈B中取出元素。如果B中没有元素，但是还是要出栈，如果A中有元素，就从A中弹出并压入B中，然后再出栈。



# 5.8寻找全排列的下一个数，即寻找一个比这个数大且仅比这个的全排列数
思路：用字典序排序算法。在寻找时，我们要尽量保持高位不变，低位在最小的范围内变换顺序，变换顺序的范围大小取决于当前数的逆序区域。

获得全排列下一个数的3个步骤：

1.从后向前（从右向左）遍历，如果能找到第一个左边的数n小于右边的数n+1就返回这个数n下标值，这就是数字交换的边界。

2.将n与它后面中大于它的最小的值进行位置交换

3.将原来的逆序区域再按由小到大排序（顺序排序）



# 5.9删除K个字符后的最小值 
思路：要使删除的K个字符后数字最小，应该从左到右遍历，然后找到第一个左边大于右边的数，然后把它删除，剩下的就是最小的数。这里还用了贪心算法的思想，每次都是删除可以删的最高位的数字，来达到局部最优解，从而实现全局最优解。



# 5.10 实现两个很大的整数相加，可以用大整数类型
思路：这个思路也是和大整数类的实现原理基本类似。用两个数组逆序存储大数，每一位一个，然后按加法来按位相加。注意数组的创建要记得长度加一，为进位保留的。

优化：原来是每一位都存在一个数组的下标中，可以将多位数存在一个数组下标中，如：50位的整数，因为一个int类型可以存10位的整数，为了防止溢出，可以每个数组下标分九位数，50位的整数可以分为长度为6的数组中，然后在相加。



# 5.11 金矿问题，和背包问题类似的动态规划问题
动态规划：把复杂的问题简化成规模较小的子问题，再从简单的子问题自底向上一步一步的递推，最终得到复杂问题的最优解。



# 5.12 寻找缺失的整数，1-n个不重复的数字中缺少了一个
思路1：存入数组，然后排序，遍历数组，看那个数不连续

思路2：求1-n的和，然后依次减去这n-1个数，结果就是缺失的数

## 扩展1：一个无序数组，范围1-n，其中n-1个数出现了偶数次，只有一个数出现了奇数次，	找这个出现奇数次的整数。

思路：用异或操作，因为异或操作在运行时，相同为0，不同为1，又因为异或满足交换律，	偶数个的数异或为0，让每一个数依次异或，最后只会剩下奇数个的数。

## 扩展2：一个无序数组，范围1-n，其中n-1个数出现了偶数次，有两个数出现了奇数次，	找这两个出现奇数次的整数。

思路：分治法，每个位数依次进行异或，最后的结果相当于两个出现奇数次的数单独异或，	最后的结果是它们异或后的二进制位一定有一个1，否则说明它们两个相等，不满足题	意，找到那个为1的位，说明在这个位上，一个数为0，一个数为1，然后将在这个位	上为1的分为一组，为0的分为一组，这样两个出现奇数次的数就不会在一个组里面，	在两个组中分别在进行异或，这样两个组异或出来的就是这两数。
