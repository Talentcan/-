# 动态规划

动态规划的四个步骤：

步骤一：定义dp数组的含义

步骤二：定义状态转移方程

步骤三：初始化过程转移的初始值

步骤四：可优化点(可选)

动态规划一般形式就是求最值，核心问题就是穷举，因为要求的是最值，把所有的值都求出来，然后就知道最值。

动态规划比较难是因为它的穷举有点特别，会存在重叠子问题，如果暴力穷举的话效率很低下。所以一般使用[备忘录]或者[DP table]来优化穷举过程，避免不必要的计算。而且动态规划问题一定会具备[最优子结构]，才能通过子问题的最值得到原问题的最值。虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有的可行的解不是一件容易的事，所以要写出正确的[状态转移方程]才能正确的穷举。写动态转移方程的思维：明确[状态]->定义dp数组/函数的含义->明确[选择]->明确base case。
例如：斐波那契数列，可以用自顶向下的方法解决，先从大的数慢慢分解，直到f(1)和f(2)触底，然后逐层返回答案。也可以用自底向上的方法，从最底层最简单规模最小的f(1)和f(2)开始往上推，这就是动态规划的思路，动态规划一般都是脱离了递归，用循环迭代来完成计算。
斐波那契数列可以写出状态转移方程：f(n){1,n=1,2;f(n-1)+f(n-2),n>2

f(n)看做一个状态n，这个状态是由n-1和n-2相加转移而来，所以是状态转移方程。列出状态转移方程式解决问题的核心。状态输安逸方程直接代表着暴力解法。
动态规划问题最困难的就是写出状态转移方程，就是这个暴力解，然后用备忘录或者DP table来优化。

## 例如：凑零钱问题
解法1：暴力递归，列举出所有可能凑出来的金额，看能不能凑出目标金额，如果可以就取出用最少的硬币数的方案。

解法2：动态规划，因为是动态规划，所以一定有最优子结构，要符合最优子结构，子问题之间就必须要相互独立。如果子问题不相互独立，最优子结构会被破坏。

列出状态方程：先确定[状态]，也就是原问题和子问题中变化的变量。在这个题目中，硬币数量无限，所以唯一的状态就是目标金额。然后确定dp函数的定义，这个题中用函数dp(n)表示当前的目标金额是n，至少需要dp(n)个硬币凑出该金额。然后确定选择并择优，也就是对于每个状态，可以做出什么选择改变当前状态。在这个题中无论当前的目标金额是多少，选择就是从面额列表中选择一个硬币，然后目标金额减少使用的硬币的金额，使用硬币数量加一。最后明确base case，这个题中，当目标金额为0时，所需硬币数量为0，当目标金额小于0时，无解。

总结：计算机解决问题其实没有任何技巧，它唯一的解决办法就是穷举，穷举出所有的可能性。算法就是先思考如何穷举，然后再追求如何聪明的穷举。列出动态转移方程是解决如何穷举，用备忘录和dp table就是在追求如何聪明的穷举，用空间换时间。




## 最优子结构详解
最优子结构是某些问题的一种特定性质，并不是动态规划问题专有的。也就是说，很多问题其实都是具有最优子结构的，只是其中大部分不具有重叠子问题，所以我们不把它们归为动态规划系列问题。最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；最优子结构性质作为动态规划的必要条件，一定是让求最值的，以后遇到那种恶心人的最值问题，思路往动态规划想，这是套路。
有些问题的子问题不是相互独立的，会有不独立的情况，。遇到这种最优子结构失效的情况，可以用改造问题的策略。

Dp数组的遍历方向

遍历的方向：在遍历的过程中，所需的状态必须是已经计算出来的并且遍历的终点必须是存储结果的那个位置。































# 回溯算法
解决一个回溯问题，实际上就是一个决策树的遍历过程。

主要思考3个点：

1.路径：就是已经做出的选择

2.选择列表：就是你当前可以做的选择

3.结束条件：就是到达决策树第层，无法再做选择的条件

代码部分：（模板）
```
result = []
def backtrack(路径, 选择列表)
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```
回溯算法核心是for循环里面的递归，在递归调用之前[做选择]，在递归调用之后[撤销选择]。
例题：全排列问题
有n个不重复的数，全排列共有n!个。
例如：全排列[1,2,3]这三个数。

可以画出这样的一棵树，只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。这棵树就可以称为回溯算法的[决策树]。
在除了叶节点的节点上，你可以进行决策，选择下一步去一条路。假设你选了最左边的一条路，那么其中[1]就是[路径]（用来记录你已经做过的选择）；[2,3]就是[选择列表]（表示当前你可以做出的选择）；[结束条件]（就是遍历到树的最底层，即叶节点，也是当选择列表为空的时候）。
在上面的模板框架上，定义的backtrack函数就像是一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，它的路径就是一个全排列。
其中如何遍历一个树，其实各种搜索问题都是树的遍历问题。
多叉树的遍历的框架：
void traverse(TreeNode root) {
    for (TreeNode child : root.childern)
        // 前序遍历需要的操作
        traverse(child);
        // 后序遍历需要的操作
}
其中所谓的前序遍历和后序遍历，它们只是两个很有用的时间点，前序遍历的代码在进入某一个节点之前点执行，后序遍历代码在离开某个节点之后的那个时间点执行。
回溯算法的核心框架（for循环里面的模板）
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
在这个模板中，我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确的得到每一节点的选择列表和路径。
例题：N皇后问题

总结：回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作。
算法框架：
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
写backtrack函数时，需要维护走过的[路径]和当前可以做的[选择列表]，当触发[结束条件]时，将[路径]记入结果集。


回溯算法的子集问题
子集：输入一个不包含重复数字的数组，要求算法输出这些数字的所有子集。如：[1,2,3]求所有的子集。
方法1：用数学归纳的思想。要求[1,2,3]的子集，可以先看[1,2]的子集[1,2]=[[],[1],[2],[1,2]]，subset([1,2,3])=subset([1,2])+[[3],[1,3],[2,3],[1,2,3]]就是相当于sebset([1,2])的结果中的每个集合再添加上3。
令A=subset[1,2],则subset([1,2,3])=A+[A[i].add(3) for i=1...len(A)]
这是一个递归结构，[1,2,3]的子集可以是[1,2]追加得到，[1,2]可以是[1]追加得到，base case就是当输入集合为空集时，输出的子集也是一个空集。
代码（C）：
vector<vector<int>> subsets(vector<int>& nums) {
    // base case，返回一个空集
    if (nums.empty()) return {{}};
    // 把最后一个元素拿出来
    int n = nums.back();
    nums.pop_back();
    // 先递归算出前面元素的所有子集
    vector<vector<int>> res = subsets(nums);

    int size = res.size();
    for (int i = 0; i < size; i++) {
        // 然后在之前的结果之上追加
        res.push_back(res[i]);
        res.back().push_back(n);
    }
    return res;
}


回溯算法解数独
思路：穷举每个空着的格子从1-9，遇到不合法的数组（在同一行同一列或同一个3*3的区域中存在相同的数字）则跳过，如果找到合法数组，填入然后继续穷举下一个空格。
代码：
boolean backtrack(char[][] board, int r, int c) {
    int m = 9, n = 9;
    if (c == n) {
        // 穷举到最后一列的话就换到下一行重新开始。
        return backtrack(board, r + 1, 0);
    }
    if (r == m) {
        // 找到一个可行解，触发 base case
        return true;
    }
    // 就是对每个位置进行穷举
    for (int i = r; i < m; i++) {
        for (int j = c; j < n; j++) {
            if (board[i][j] != '.') {
                // 如果有预设数字，不用我们穷举
                return backtrack(board, i, j + 1);
            } 
            for (char ch = '1'; ch <= '9'; ch++) {
                // 如果遇到不合法的数字，就跳过
                if (!isValid(board, i, j, ch))
                    continue;
                board[i][j] = ch;
                // 如果找到一个可行解，立即结束
                if (backtrack(board, i, j + 1)) {
                    return true;
                }
                board[i][j] = '.';
            }
            // 穷举完 1~9，依然没有找到可行解，此路不通
            return false;
        }
    }
    return false;
}
boolean isValid(char[][] board, int r, int c, char n) {
    for (int i = 0; i < 9; i++) {
        // 判断行是否存在重复
        if (board[r][i] == n) return false;
        // 判断列是否存在重复
        if (board[i][c] == n) return false;
        // 判断 3 x 3 方框是否存在重复
        if (board[(r/3)*3 + i/3][(c/3)*3 + i%3] == n)
            return false;
    }
    return true;}





































